{"filter":false,"title":"dictionary.c","tooltip":"/pset5/dictionary.c","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":9,"column":0},"end":{"row":48,"column":0},"action":"remove","lines":["#include <stdbool.h>","","#include \"dictionary.h\"","","/**"," * Returns true if word is in dictionary else false."," */","bool check(const char* word)","{","    // TODO","    return false;","}","","/**"," * Loads dictionary into memory.  Returns true if successful else false."," */","bool load(const char* dictionary)","{","    // TODO","    return false;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    // TODO","    return 0;","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    // TODO","    return false;","}",""],"id":2},{"start":{"row":9,"column":0},"end":{"row":171,"column":1},"action":"insert","lines":["#include <ctype.h>","#include <stdbool.h>","#include <stdio.h>","#include <stdlib.h>","","#include \"dictionary.h\"","","// Node Definition","typedef struct node","{","    bool is_word;","    struct node* children[27];","}","node;","","// Root Node","node* root;","","// Size of trie","unsigned int total_nodes = 0;","","/**"," * Returns index of letter within trie array"," */","int getIndex(const char c)","{","    if (c == '\\'') ","    {","        return 26;    ","    }","    else ","    {","        return tolower(c) % 'a';","    }","}","","/**"," * Returns true if word is in dictionary else false."," */","bool check(const char* word)","{","    // Set cursor to root","    node* cursor = root;","    ","    // for each letter in input word","    for (int i = 0; word[i] != '\\0'; i++) ","    {","        // Find the index of the letter","        int index = getIndex(word[i]);","        ","        // got to corresponding element in children","        if (cursor->children[index] == NULL) ","        {","            // if NULL word is mispelled","            return false;","        }","        ","        // if not NULL, move to next letter","        cursor = cursor->children[index];","    }","    ","    // once at end of input word, check if is_word is true","    return cursor->is_word;","}","","/**"," * Loads dictionary into memory.  Returns true if successful else false."," */","bool load(const char* dictionary)","{","    // Create space for root","    root = malloc(sizeof(node));","    ","    // Initialize number of nodes","    total_nodes = 0;","    ","    // Read dictionary","    FILE* fp = fopen(dictionary, \"r\");","    if (fp == NULL)","    {","        printf(\"Could not open %s.\\n\", dictionary);","        unload();","        return false;","    }","    ","    // Set cursor to root","    node* cursor = root;","    ","    // Read each character in dictionary","    for (int c = fgetc(fp); c != EOF; c = fgetc(fp))","    {","        // Check if newline","        if (c == '\\n') ","        {","            // mark as word","            cursor->is_word = true;","            ","            // Increment number of nodes","            total_nodes++;","            ","            // reset cursor to root to traverse trie again","            cursor = root;","        }","        else ","        {","            // Find the index of the letter","            int index = getIndex(c);","            ","            // Check if node exists for letter","            if (cursor->children[index] == NULL) ","            {","                // Create new node","                cursor->children[index] = malloc(sizeof(node));","            }","","            // Move to next node","            cursor = cursor->children[index];","        }","    }","    ","    // Close dictionary","    fclose(fp);","    ","    return true;","}","","/**"," * Returns number of words in dictionary if loaded else 0 if not yet loaded."," */","unsigned int size(void)","{","    return total_nodes;","}","","/**"," * Check node children to see if they can be freed"," */","bool free_nodes(node* ptr)","{","    // Go through node's children","    for (int i = 0; i < 27; i++)","    {","        // If child is pointer, recursively check that one as well","        if (ptr->children[i] != NULL) ","        {","            free_nodes(ptr->children[i]);","        }","    }","    ","    // If all chilren are null, free node","    free(ptr);","    ","    return true;","}","","/**"," * Unloads dictionary from memory.  Returns true if successful else false."," */","bool unload(void)","{","    // Start at root","    return free_nodes(root);","}"]}]]},"ace":{"folds":[],"scrolltop":1840,"scrollleft":0,"selection":{"start":{"row":12,"column":19},"end":{"row":12,"column":19},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":27,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1478012174428,"hash":"907345e9655a73f6bbed2893a5487b37151cb94a"}